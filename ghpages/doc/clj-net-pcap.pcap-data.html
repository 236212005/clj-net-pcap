<!DOCTYPE html><html><head><meta charset="utf-8" /><title>Namespace clj-net-pcap.pcap-data</title><style type="text/css">body { margin: 10px;
          padding: 10px;
          background-color: #F7F7F7;
          font-family: serif; }

  h1, h2, h3, h4 { color:#116275; }

  code { font-size:12px;
         font-family: monospace; }

  pre { padding: 5px;
        border: 2px dashed DarkGray;
        background-color: #F7F7F7;
        font-size:12px;
        font-family: monospace; }

  a { color: #116275; }
  a:hover { background-color: #A8DFE6; }
  a:visited { color: #276B86; }

  td { padding-left: 5px; }

  section, footer, header { float: left; }

  #top { width: 800px;
         padding: 10px;
         margin-left: auto;
         margin-right: auto;
         overflow: hidden;
         background-color: #FFFFFF;
         border: 3px solid DarkGray; }</style></head><body><div id="top"><header><h1>Namspace clj-net-pcap.pcap-data</h1><h4></h4></header><section id="ns-toc"><h2>Other Namespaces</h2><table><tr><td><a href="clj-net-pcap.CljNetPcapJavaAdapter.html">clj-net-pcap.CljNetPcapJavaAdapter</a></td><td><div>Adapter class to enable usage of clj-net-pcap from Java.</div></td></tr><tr><td><a href="clj-net-pcap.core.html">clj-net-pcap.core</a></td><td><div></div></td></tr><tr><td><a href="clj-net-pcap.main.html">clj-net-pcap.main</a></td><td><div>Main class and method for launching a simple clj-net-pcap based sniffer
          that prints some i...</div></td></tr><tr><td><a href="clj-net-pcap.native.html">clj-net-pcap.native</a></td><td><div></div></td></tr><tr><td><a href="clj-net-pcap.pcap.html">clj-net-pcap.pcap</a></td><td><div></div></td></tr><tr><td><a href="clj-net-pcap.sniffer.html">clj-net-pcap.sniffer</a></td><td><div></div></td></tr><tr><td><a href="index.html">Back to Index</a></td><td></td></tr></table></section><section id="pubvars-toc"><h2>Public Vars</h2><nav><a href="#IDextract-http-fields-to-map">extract-http-fields-to-map</a>, <a href="#IDextract-subnet-information-to-map">extract-subnet-information-to-map</a>, <a href="#IDguess-subnet">guess-subnet</a>, <a href="#IDguess-subnet-mask">guess-subnet-mask</a>, <a href="#IDguess-subnet-mask-bits">guess-subnet-mask-bits</a>, <a href="#IDnetwork-class">network-class</a>, <a href="#IDparse-pcap-header-to-map">parse-pcap-header-to-map</a>, <a href="#IDparse-pcap-packet">parse-pcap-packet</a>, <a href="#IDparse-protocol-headers-to-map">parse-protocol-headers-to-map</a>, <a href="#IDpcap-packet-to-byte-vector">pcap-packet-to-byte-vector</a>, <a href="#IDprettify-addr-array">prettify-addr-array</a>, <a href="#IDprocess-protocol-headers-to-map">process-protocol-headers-to-map</a>, <a href="#IDsrc-dst-to-map">src-dst-to-map</a>, <a href="#IDstdout-byte-array-forwarder-fn">stdout-byte-array-forwarder-fn</a>, <a href="#IDstdout-combined-forwarder-fn">stdout-combined-forwarder-fn</a>, <a href="#IDstdout-forwarder-fn">stdout-forwarder-fn</a></nav></section><section id="details"><h2>Details of Public Vars</h2><div id="IDextract-http-fields-to-map"><div><h3>Function: extract-http-fields-to-map</h3><pre>Arglists:
=========

  (extract-http-fields-to-map http fields)

Docstring:
==========

  Extract the given fields from an org.jnetpcap.protocol.tcpip.Http instance and store each into a map.
   fields is a vector that specifies which fields shall be extracted.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L137">View Source</a></div><div id="IDextract-subnet-information-to-map"><div><h3>Macro: extract-subnet-information-to-map</h3><pre>Arglists:
=========

  (extract-subnet-information-to-map protocol)

Docstring:
==========

  Try to get information about source and destination subnets like network addresses or subnet masks.
   This is just a wild guess based on the private network ranges as defined in RFC 1918.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L126">View Source</a></div><div id="IDguess-subnet"><div><h3>Function: guess-subnet</h3><pre>Arglists:
=========

  (guess-subnet ip-addr)

Docstring:
==========

  Try to guess the subnet address based on private network classes as defined in RFC 1918.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L45">View Source</a></div><div id="IDguess-subnet-mask"><div><h3>Function: guess-subnet-mask</h3><pre>Arglists:
=========

  (guess-subnet-mask ip-addr)

Docstring:
==========

  Try to guess the subnet mask based on private network classes as defined in RFC 1918.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L56">View Source</a></div><div id="IDguess-subnet-mask-bits"><div><h3>Function: guess-subnet-mask-bits</h3><pre>Arglists:
=========

  (guess-subnet-mask-bits ip-addr)

Docstring:
==========

  Try to guess the number of bits in the subnet mask based on private network classes as defined in RFC 1918.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L66">View Source</a></div><div id="IDnetwork-class"><div><h3>Function: network-class</h3><pre>Arglists:
=========

  (network-class ip-addr)

Docstring:
==========

  Determine the network class based on the private network classes as defined in RFC 1918. This assume no CIDR is used.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L36">View Source</a></div><div id="IDparse-pcap-header-to-map"><div><h3>Function: parse-pcap-header-to-map</h3><pre>Arglists:
=========

  (parse-pcap-header-to-map packet)

Docstring:
==========

  Parse the information contained in the pcap header of a org.jnetpcap.packet.PcapPacket instance
   and store it into a map. The resulting map is returned.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L220">View Source</a></div><div id="IDparse-pcap-packet"><div><h3>Function: parse-pcap-packet</h3><pre>Arglists:
=========

  (parse-pcap-packet packet)

Docstring:
==========

  Convenience function to parse a org.jnetpcap.packet.PcapPacket into a map.
   The result contains the pcap header and protocol header information.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L234">View Source</a></div><div id="IDparse-protocol-headers-to-map"><div><h3>Function: parse-protocol-headers-to-map</h3><pre>Arglists:
=========


Docstring:
==========

  No docs attached.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L147">View Source</a></div><div id="IDpcap-packet-to-byte-vector"><div><h3>Function: pcap-packet-to-byte-vector</h3><pre>Arglists:
=========

  (pcap-packet-to-byte-vector pcap-packet)

Docstring:
==========

  Convert the given org.jnetpcap.packet.PcapPacket to its byte array representation and return it as vector.
   This can be handy for debugging purposes as the resulting vector can be easily converted back into a org.jnetpcap.packet.PcapPacket instance.

   The re-assembly process is as follows:
[rc@WOPR dist]$ CLASSPATH=$CLASSPATH:clj-net-pcap-1.3.1.jar:../lib/jnetpcap-1.4.r1390-1b.jar:../lib/clj-assorted-utils-1.0.0.jar clojure
Clojure 1.5.1
user=&gt; (use 'clj-net-pcap.native)
nil
user=&gt; (extract-and-load-native-libs)
nil
user=&gt; (import '(org.jnetpcap.packet PcapPacket))
org.jnetpcap.packet.PcapPacket
user=&gt; (import '(org.jnetpcap.nio JMemory))
org.jnetpcap.nio.JMemory
user=&gt; (import '(org.jnetpcap.nio JMemory$Type))
org.jnetpcap.nio.JMemory$Type
user=&gt; (def pkt (PcapPacket. JMemory$Type/POINTER))
#'user/pkt
user=&gt; (def ba (byte-array (map byte [22 3 -110 81 0 0 0 0 100 12 2 0 0 0 0 0 -48 0 0 0 -48 0 0 0 42 0 0 0 0 0 0 0 -9 -82 104 95 1 0 3 0 3 3 5 0 12 95 104 83 -1 2 0 12 17 0 0 0 17 0 0 0 67 -12 0 0 108 7 0 0 -1 2 0 12 12 95 104 83 17 0 0 0 17 0 0 0 108 7 0 0 67 -12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -48 0 0 0 -48 0 0 0 4 0 0 0 0 0 0 0 1 0 0 0 0 8 0 0 0 0 0 0 14 0 0 0 -62 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 8 0 0 14 0 0 0 40 0 0 0 -102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 8 0 0 54 0 0 0 8 0 0 0 -110 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 62 0 0 0 -110 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 51 51 0 0 0 12 8 0 39 113 22 114 -122 -35 96 0 0 0 0 -102 17 1 -2 -128 0 0 0 0 0 0 81 -56 104 119 -93 23 0 36 -1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 12 -12 67 7 108 0 -102 69 -96 77 45 83 69 65 82 67 72 32 42 32 72 84 84 80 47 49 46 49 13 10 72 111 115 116 58 91 70 70 48 50 58 58 67 93 58 49 57 48 48 13 10 83 84 58 117 114 110 58 77 105 99 114 111 115 111 102 116 32 87 105 110 100 111 119 115 32 80 101 101 114 32 78 97 109 101 32 82 101 115 111 108 117 116 105 111 110 32 80 114 111 116 111 99 111 108 58 32 86 52 58 73 80 86 54 58 76 105 110 107 76 111 99 97 108 13 10 77 97 110 58 34 115 115 100 112 58 100 105 115 99 111 118 101 114 34 13 10 77 88 58 51 13 10 13 10])))
#'user/ba
user=&gt; (.transferStateAndDataFrom pkt ba)
576
  user=&gt; (import '(org.jnetpcap.protocol.network Ip6))
org.jnetpcap.protocol.network.Ip6
user=&gt; (def ip6 (Ip6.))
#'user/ip6
user=&gt; (.hasHeader pkt ip6)
true
user=&gt; (.source ip6)
#&lt;byte[] [B@3c1c6c94&gt;
user=&gt; (use 'clj-net-pcap.pcap-data)
nil
user=&gt; (prettify-addr-array (.source ip6))
&quot;FE80::51C8:6877:A317:0024&quot;
user=&gt;
  </pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L248">View Source</a></div><div id="IDprettify-addr-array"><div><h3>Function: prettify-addr-array</h3><pre>Arglists:
=========

  (prettify-addr-array a)

Docstring:
==========

  Convenience function to print addresses as strings.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L76">View Source</a></div><div id="IDprocess-protocol-headers-to-map"><div><h3>Macro: process-protocol-headers-to-map</h3><pre>Arglists:
=========

  (process-protocol-headers-to-map packet &amp; headers)

Docstring:
==========

  Macro for processing protocol header information into a map representation.
   packet is a org.jnetpcap.packet.PcapPacket instance.
   headers contains the description about which information shall be retrieved for each protocol.

   For an example usage see parse-protocol-headers-to-map.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L87">View Source</a></div><div id="IDsrc-dst-to-map"><div><h3>Macro: src-dst-to-map</h3><pre>Arglists:
=========

  (src-dst-to-map protocol)

Docstring:
==========

  Write source and destination addresses into a map.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L120">View Source</a></div><div id="IDstdout-byte-array-forwarder-fn"><div><h3>Function: stdout-byte-array-forwarder-fn</h3><pre>Arglists:
=========

  (stdout-byte-array-forwarder-fn packet)

Docstring:
==========

  Print the byte vector representation of a org.jnetpcap.packet.PcapPacket as returned by pcap-packet-to-byte-vector to *out*.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L296">View Source</a></div><div id="IDstdout-combined-forwarder-fn"><div><h3>Function: stdout-combined-forwarder-fn</h3><pre>Arglists:
=========

  (stdout-combined-forwarder-fn packet)

Docstring:
==========

  No docs attached.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L303">View Source</a></div><div id="IDstdout-forwarder-fn"><div><h3>Function: stdout-forwarder-fn</h3><pre>Arglists:
=========

  (stdout-forwarder-fn packet)

Docstring:
==========

  Pre-defined forwarder function which outputs information about org.jnetpcap.packet.PcapPacket to *out*.
   The information is in form of a map. The is pretty printed with pprint.</pre></div><a href="#top">Back to top</a> <a href="https://github.com/ruedigergad/clj-net-pcap/blob/master/src/clj_net_pcap/pcap_data.clj#L290">View Source</a></div></section><footer><p>These docs were generated by the <a href="https://github.com/tsdh/lein-html5-docs">Leiningen HTML5 Docs Plugin</a>.</p><a href="http://www.w3.org/html/logo/"><img alt="HTML5 Powered" height="64" src="http://www.w3.org/html/logo/badge/html5-badge-h-solo.png" title="HTML5 Powered" width="63" /></a></footer></div></body></html>